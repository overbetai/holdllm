<!DOCTYPE HTML>
<html lang="en-US">
   <head>
       <script async src="https://www.googletagmanager.com/gtag/js?id=G-DV7SM4LPKG"></script>
       <script>
       window.dataLayer = window.dataLayer || [];
       function gtag(){dataLayer.push(arguments);}
       gtag('js', new Date());

       gtag('config', 'G-DV7SM4LPKG');
       </script>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
        <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
        <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
        <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script> 

        <script>
            window.addEventListener('load', function() {
                console.log('React available:', typeof React !== 'undefined');
                console.log('ReactDOM available:', typeof ReactDOM !== 'undefined');
            });
        </script>

       <title>Overbet.ai</title>
       <link rel="icon" type="image/png" href="https://overbet.ai/logo_small.png">
       <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
       <style>
           body {
               font-family: Arial, sans-serif;
               margin: 0;
               padding: 0;
               background-color: #f5f5f5;
               min-height: 100vh;
               position: relative;
           }
           
           .header {
               text-align: center;
               padding: 20px;
           }

           .hero-section {
               background-color: #425B76;
               color: white;
               padding: 30px 20px;
               margin-bottom: 20px;
           }

           .main-content {
               text-align: center;
               max-width: 12500px;
               margin: 0 auto;
           }

           h1 {
               margin: 0 0 20px 0;
           }

           .game-preview {
               background: #2B6D5E;
               border: 2px solid rgba(255, 255, 255, 0.2);
               border-radius: 12px;
               width: 500px;
               height: 300px;
               margin: 20px auto;
               position: relative;
           }

           .bot-container {
               position: absolute;
               width: 100px;
               text-align: center;
           }

           .bot-container:nth-child(1) {
               top: 20px;
               left: 50%;
               transform: translateX(-50%);
           }

           .bot-container:nth-child(2) {
               top: 50%;
               right: 20px;
               transform: translateY(-50%);
           }

           .bot-container:nth-child(3) {
               bottom: 20px;
               left: 50%;
               transform: translateX(-50%);
           }

           .bot-container:nth-child(4) {
               top: 50%;
               left: 20px;
               transform: translateY(-50%);
           }

           .robot-icon {
               background: rgba(255, 255, 255, 0.15);
               border-radius: 50%;
               width: 80px;
               height: 80px;
               display: flex;
               align-items: center;
               justify-content: center;
               margin: 0 auto 10px;
           }

           .white-icon {
               color: white;
               font-size: 32px;
           }

           .bot-name {
               color: white;
               font-size: 14px;
               margin-top: 5px;
           }

           .signup-section {
               text-align: center;
               padding: 20px;
           }

           .signup-section h2 {
               margin: 0 0 10px 0;
           }

           .signup-section p {
               margin: 0 0 20px 0;
           }

           .email-form {
               display: flex;
               justify-content: center;
               gap: 10px;
               max-width: 500px;
               margin: 20px auto;
           }

           .email-input {
               padding: 12px 20px;
               border: 2px solid #ddd;
               border-radius: 6px;
               width: 300px;
               font-size: 16px;
           }

           .signup-button {
               background: #425B76;
               color: white;
               padding: 12px 24px;
               border-radius: 6px;
               border: none;
               font-weight: bold;
               cursor: pointer;
           }

           .signup-button:hover {
               opacity: 0.9;
           }

           .grid-container {
               display: grid;
               grid-template-columns: repeat(3, 1fr);
               gap: 30px;
               max-width: 1200px;
               margin: 20px auto;
               padding: 0 20px;
           }

           .grid-item {
               background: white;
               padding: 30px;
               border-radius: 12px;
               box-shadow: 0 4px 6px rgba(0,0,0,0.1);
               display: flex;
               flex-direction: column;
               align-items: center;
               text-align: center;
           }

           .grid-item:nth-child(1) { background-color: #e8f5e9; }
           .grid-item:nth-child(2) { background-color: #e3f2fd; }
           .grid-item:nth-child(3) { background-color: #fff3e0; }

           .icon-container {
               background: white;
               border-radius: 50%;
               width: 80px;
               height: 80px;
               display: flex;
               align-items: center;
               justify-content: center;
               margin-bottom: 20px;
               box-shadow: 0 2px 4px rgba(0,0,0,0.1);
           }

           .icon-color {
               color: #425B76;
               font-size: 32px;
           }

           .grid-item h3 {
               margin: 0 0 15px 0;
               color: #333;
               font-size: 1.5rem;
           }

           .grid-item p {
               color: #666;
               margin: 0 0 20px 0;
               flex-grow: 1;
           }

           .button {
               background: white;
               color: #425B76;
               padding: 12px 24px;
               border-radius: 6px;
               text-decoration: none;
               font-weight: bold;
               transition: all 0.2s;
               border: 2px solid #425B76;
           }

           .button:hover {
               background: #425B76;
               color: white;
               text-decoration: none;
           }

           footer {
               text-align: center;
               padding: 20px;
               color: #666;
               margin-top: 20px;
               position: relative;
           }
        </style>  

        <link rel="stylesheet" href="holdllm.css">

        <style>
            .spinner-container {
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 300px;
            }

            .spinner {
                width: 50px;
                height: 50px;
                border: 5px solid #f3f3f3;
                border-top: 5px solid #425B76;
                border-radius: 50%;
                animation: spin 1s linear infinite;
            }

            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        </style>
   </head>
   <body>
       <div class="header">
           <img src="https://overbet.ai/logo.png" width="366" height="71" alt="Overbet.ai Logo">
       </div>

       <div class="hero-section">
           <div class="main-content">
               <h1>Texas Hold'LLM</h1>
               <div class="layout">
                    <div id="visualization-container"></div>
                    <div id="debug-container"></div>
                </div>
               <!--<div class="game-preview">
                   <div class="bot-container">
                       <div class="robot-icon">
                           <i class="fas fa-solid fa-robot white-icon"></i>
                       </div>
                       <div class="bot-name">Grok</div>
                   </div>
                   <div class="bot-container">
                       <div class="robot-icon">
                           <i class="fas fa-regular fa-robot white-icon"></i>
                       </div>
                       <div class="bot-name">Claude</div>
                   </div>
                   <div class="bot-container">
                       <div class="robot-icon">
                           <i class="fas fa-light fa-robot white-icon"></i>
                       </div>
                       <div class="bot-name">ChatGPT</div>
                   </div>
                   <div class="bot-container">
                       <div class="robot-icon">
                           <i class="fas fa-thin fa-robot white-icon"></i>
                       </div>
                       <div class="bot-name">Gemini</div>
                   </div>
               </div>-->
           </div>
       </div>

       <div class="signup-section">
           <h2>Think you could do better?</h2>
           <!-- <p>Check out the prompts that we used here. Think you could do better? </p> -->
           <p>Sign up to get notified when we launch!</p>
           <!-- <div style="position: relative; width: 480px; height: 70px; overflow: hidden;">
            <iframe
              src="https://overbetai.substack.com/embed"
              width="480"
              height="320"
              style="border: 1px solid #EEE; background: white; position: relative; top: -170px;"
              frameborder="0"
              scrolling="no"
            ></iframe>
          </div> -->
           <iframe src="https://overbetai.substack.com/embed" width="480" height="150" style="border:1px solid #EEE; background:white;" frameborder="0" scrolling="no"></iframe>

       <div class="grid-container">
           <div class="grid-item">
               <div class="icon-container">
                   <i class="fas fa-solid fa-diamond icon-color"></i>
               </div>
               <h3>Cards to Code</h3>
               <p>Build your first AI poker bot and learn the fundamentals of game theory</p>
               <a href="#" class="button">Go (soon)</a>
               <!-- <a href="https://cardstocode.com" class="button">Go</a> -->
           </div>
           <div class="grid-item">
               <div class="icon-container">
                   <i class="fas fa-solid fa-brain icon-color"></i>
               </div>
               <h3>RPS Opponent Modeling</h3>
               <p>Master opponent modeling through the classic game of rock paper scissors</p>
               <a href="#" class="button">Go (soon)</a>
               <!-- <a href="https://rps.bot" class="button">Go</a> -->
           </div>
           <div class="grid-item">
               <div class="icon-container">
                   <i class="fas fa-regular fa-hand-back-fist icon-color"></i>
               </div>
               <h3>Daily RPS Challenge</h3>
               <p>Test your skills in our daily rock paper scissors challenge</p>
               <a href="#" class="button">Play (soon)</a>
               <!-- <a href="https://overbet.ai/daily" class="button">Play</a> -->
           </div>
       </div>

       <footer>© 2024 Overbet.ai</footer>

       <script type="text/babel">
const { useState, useEffect } = React;

const PLAYER_NAMES = {
    0: "Claude 3.5 Sonnet",
    1: "Gemini 1.5-flash", 
    2: "GPT-4o",
    3: "Grok-beta"
};

console.log("Constants loaded:", window.PLAYER_NAMES);

const PLAYER_SHORT_NAMES = {
    0: "Claude",
    1: "Gemini", 
    2: "GPT",
    3: "Grok"
};

const PLAYER_CLASS = {
    0: "player-claude",
    1: "player-gemini", 
    2: "player-gpt",
    3: "player-grok"
};

const CHIP_DENOMS = [
    { value: 500, color: '#800080', label: '500' },
    { value: 100, color: '#333333', label: '100' },
    { value: 25, color: '#008000', label: '25' },
    { value: 5, color: '#FF0000', label: '5' },
    { value: 1, color: '#FFFFFF', label: '1' }
];

const suitSymbols = {
    's': '♠',
    'h': '♥',
    'd': '♦',
    'c': '♣'
};

const suitClasses = {
    's': 'poker-card-spades',
    'h': 'poker-card-hearts', 
    'd': 'poker-card-diamonds',
    'c': 'poker-card-clubs'
};


const Circle = ({ size, fill, color, strokeWidth, style, strokeDasharray }) => (
    <div className="chip" style={{
        width: size + 'px',
        height: size + 'px',
        backgroundColor: fill,
        border: `${strokeWidth}px ${strokeDasharray ? 'dashed' : 'solid'} ${color}`,
        borderStyle: strokeDasharray ? 'dashed' : 'solid',
        ...style
    }} />
);

const SingleChip = ({ color }) => (
    <div style={{ position: 'relative' }}>
        <Circle
            size={24}
            fill={color}
            color={color === '#000000' ? 'black' : 'black'}
            strokeWidth={2}
        />
        {/* Black circle overlay */}
        <Circle
            size={24}
            fill="transparent"
            color="black"
            strokeWidth={2}
            style={{
                position: 'absolute',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)'
            }}
        />
    </div>
);

const BetStack = ({ amount, horizontal = false }) => {
    if (amount === 0) return null;

    let remaining = amount;
    const chipStacks = horizontal ? [] : [[]];
    
    for (const denom of CHIP_DENOMS) {
        const count = Math.floor(remaining / denom.value);
        if (count > 0) {
            for (let i = 0; i < count; i++) {
                if (horizontal) {
                    if (chipStacks.length > 0 && chipStacks[chipStacks.length-1][0].value === denom.value) {
                        chipStacks[chipStacks.length-1].push(denom);
                    } else {
                        chipStacks.push([denom]);
                    }
                } else {
                    chipStacks[0].push(denom);
                }
            }
            remaining -= count * denom.value;
        }
    }

    return (
        <div className="bet-stack">
            {chipStacks.map((stack, stackIndex) => (
                stack.map((chip, i) => (
                    <div
                        key={`${chip.value}-${stackIndex}-${i}`}
                        style={{
                            position: 'absolute',
                            bottom: `${i * 6}px`,
                            left: `calc(50% + ${stackIndex * 29}px)`,
                            transform: 'translateX(-50%)',
                            zIndex: 100+i
                        }}
                    >
                        <SingleChip color={chip.color} />
                    </div>
                ))
            ))}
            <div style={{
                position: 'absolute',
                left: `calc(50% + ${(chipStacks.length - 1) * 29/2}px)`,
                bottom: `5px`,
                transform: 'translateX(-50%)',
                color: 'white',
                fontSize: '14px',
                fontWeight: 'bold',
                whiteSpace: 'nowrap',
                zIndex: 200
            }}>
                ${amount}
            </div>
        </div>
    );
};

const DealerButton = ({ style }) => {
    return (
        <div className="dealer-button" style={style}>
            D
        </div>
    );
};

const PokerCard = ({ card }) => {
    if (!card) return null;
    
    
    return (
        <div className={`poker-card ${suitClasses[card.suit]}`}>
            {card.rank}{suitSymbols[card.suit]}
        </div>
    );
};

const TextCard = ({ card }) => {
    if (!card) return null;

    return <span className={`text-card ${suitClasses[card.suit]}`}>{card.rank}{suitSymbols[card.suit]}</span>;
};

// interface TableCenterProps {
//     board: Card[][]
//     street: number
//     pot: number
//     prevStreetPot: number
// }

const TableCenter = ({ board, street, pot, prevStreetPot }/*: TableCenterProps*/) => {
    return (
        <div style={{
            position: 'absolute',
            top: '35%',
            left: '25%',
            width: '50%',
            height: '28%',
        }}>
            {/* Total Pot Display */}
            <div className="total-pot-display" style={{top: street === 0 ? '30%' : '0'}}>
                <span><strong>Pot: ${pot}</strong></span>
            </div>
            
            {/* Board Cards */}
            <div className="board-cards">
                {(board || []).map((streetCards, streetIndex) => (
                    streetCards.map((card, cardIndex) => (
                        <div key={`${streetIndex}-${cardIndex}`} 
                            style={{ opacity: streetIndex >= street ? 0 : 1 }}>
                            <PokerCard card={card} />
                        </div>
                    ))
                ))}
            </div>


            {/* Previous Street Pot */}
            <div className="prev-pot-display" style={{
                position: 'absolute',
                top: '90%',  // Adjust this to move up/down
                left: '40%', // This positions it between 4th and 5th card
                transform: 'translate(-50%, -50%)',
            }}>
                <BetStack 
                    amount={prevStreetPot}
                    horizontal={true}
                />
            </div>
        </div>
    );
};

/*interface PlayerProps {
    index: number
    name: string
    shortName: string
    stack: number
    sessionDelta: number
    position: {
        info: { left: string, top: string }
        cards: { left: string, top: string }
        bet: { left: string, top: string }
    }
    cards: Card[]
    displayedBet: number
    isActive: boolean
    isLive: boolean
    isDealer: boolean
    playerClass: string
}*/

const Player = ({ 
    index, name, shortName, stack, sessionDelta, position, 
    cards, displayedBet, displayedExtraBet, isActive, isLive, isDealer, playerClass 
}/*: PlayerProps*/) => {
    const isLeftToRight = (index === 0 || index === 3);

    return (
        <React.Fragment>
            {/* Player Info Box */}
            <div className={`player-info ${playerClass}`} style={{
                left: position.info.left,
                top: position.info.top,
            }}>
                <div className={`player-info-box ${isActive ? 'player-info-box-active' : ''} ${
                    isLive ? '' : 'player-info-box-not-live'
                }`}>
                    <div>{name}</div>
                    <div>${stack} ({sessionDelta >= 0 ? '+' : '-'}${Math.abs(sessionDelta)} session)</div>
                </div>
            </div>

            {/* Player Cards */}
            <div className={`player-cards ${isLive ? '' : 'player-cards-not-live'}`} style={{
                left: position.cards.left,
                top: position.cards.top,
                position: "absolute",
            }}>
                {isDealer && (
                    <DealerButton style={{
                        top: "50%",
                        left: isLeftToRight ? -22 : "auto",
                        right: isLeftToRight ? "auto" : -62,
                    }} />
                )}

                {(cards || []).map((card, cardIdx) => (
                    <PokerCard key={cardIdx} card={card} />
                ))}

                <div className="player-bet" style={{
                    top: "70%",
                    left: isLeftToRight ? "auto" : -20,
                    right: isLeftToRight ? -48 : "auto",
                    transform: "translateX(-50%) translateY(-50%)",
                }}>
                    <BetStack 
                        amount={displayedBet}
                    />
                </div>

                <div className="player-bet" style={{
                    top: "70%",
                    left: isLeftToRight ? "auto" : -52,
                    right: isLeftToRight ? -80 : "auto",
                    transform: "translateX(-50%) translateY(-50%)",
                }}>
                    <BetStack 
                        amount={displayedExtraBet}
                    />
                </div>
            </div>

            {/* Bet Stack */}
            
        </React.Fragment>
    );
};

const GameTable = ({ handInfo, gameState, rawGameState, payoffs = undefined, cumulativePayoffs = [0, 0, 0, 0] }) => {
    const calculatePlayerPositions = (numPlayers) => {
        return [...Array(numPlayers)].map((_, i) => {
            const angles = {
                0: -120, // NW
                1: -40,  // NE
                2: 65,   // SE
                3: 140   // SW
            };
            const angle = angles[i] * (Math.PI / 180);

            const aOuter = 59;
            const bOuter = 50;
            const aInner = 38;
            const bInner = 32;


            // Adjust bet offsets for diagonal positions
            let betOffset;
            if (i === 0) {      // NW
                betOffset = { x: 10, y: 10 };
            } else if (i === 1) { // NE
                betOffset = { x: -10, y: 10 };
            } else if (i === 2) { // SE
                betOffset = { x: -10, y: -10 };
            } else {              // SW
                betOffset = { x: 10, y: -10 };
            }

            const cardPos = {
                left: 50 + aInner * Math.cos(angle),
                top: 50 + bInner * Math.sin(angle)
            };
            
            return {
                info: {
                    left: `${50 + aOuter * Math.cos(angle)}%`,
                    top: `${50 + bOuter * Math.sin(angle)}%`,
                },
                cards: {
                    left: `${cardPos.left}%`,
                    top: `${cardPos.top}%`,
                },
                bet: {
                    left: `${cardPos.left + betOffset.x}%`,
                    top: `${cardPos.top + betOffset.y}%`,
                }
            };
        });
    };

    const positions = calculatePlayerPositions(handInfo.players);

    const isPayoffState = payoffs !== undefined;

    // Calculate pot values
    const totalPot = (
        (rawGameState.chips_paid_previous_streets || []).reduce((sum, chips) => sum + chips, 0)
        + (rawGameState.chips_paid_this_street || []).reduce((sum, chips) => sum + chips, 0)
    );
    
    const prevStreetPot = isPayoffState ? 0 : (
        (rawGameState.chips_paid_previous_streets || []).reduce((sum, chips) => sum + chips, 0)
    );

    // Calculate player bets - during payoff, show net win/loss
    const getDisplayedBet = (index) => {
        if (!isPayoffState) {
            return rawGameState.chips_paid_this_street[index];
        } else {
            // Calculate total chips paid by this player
            const totalPaid = (rawGameState.chips_paid_previous_streets[index] || 0) + 
                            (rawGameState.chips_paid_this_street[index] || 0);
            // Payoff minus total chips paid = net win/loss
            return (payoffs[index] || 0) + totalPaid;
        }
    };

    return (
        <div className="game-table">
            <div className="table-surface">
                <div className="table-content">
                    <img src="https://overbet.ai/logo.png" className="table-logo" alt="Overbet AI Logo" />

                    <TableCenter 
                        board={rawGameState.board}
                        street={rawGameState.street}
                        pot={totalPot}
                        prevStreetPot={prevStreetPot}
                    />

                    {/* All players using new Player component */}
                    {positions.map((pos, i) => (
                        <Player 
                            key={i}
                            index={i}
                            name={PLAYER_NAMES[i]}
                            shortName={PLAYER_SHORT_NAMES[i]}
                            stack={rawGameState.starting_stack[i] - rawGameState.chips_paid_this_street[i] - rawGameState.chips_paid_previous_streets[i]}
                            sessionDelta={cumulativePayoffs[i]}
                            position={pos}
                            cards={rawGameState.hands[i]}
                            displayedBet={isPayoffState && payoffs[i] <= 0 ? 0 : rawGameState.chips_paid_this_street[i]}
                            displayedExtraBet={isPayoffState && payoffs[i] > 0 ? payoffs[i] + rawGameState.chips_paid_previous_streets[i] : 0}
                            isActive={rawGameState.player_to_act === i}
                            isLive={rawGameState.player_live[i]}
                            isDealer={rawGameState.dealer_button === i}
                            playerClass={PLAYER_CLASS[i]}
                        />
                    ))}
                </div>
            </div>
        </div>
    );
};

function GameVisualizer({ gameState, payoffs, cumulativePayoffs }) {
    if (!gameState) return null;

    // Calculate pot (sum of all chips paid in previous rounds)
    const totalPot = (gameState.chips_paid_previous_streets || []).reduce((sum, chips) => sum + chips, 0) +
                    (gameState.chips_paid_this_street || []).reduce((sum, chips) => sum + chips, 0);

    const prevStreetPot = (gameState.chips_paid_previous_streets || []).reduce((sum, chips) => sum + chips, 0);

    // Calculate remaining chips for each player
    const remainingChips = (gameState.starting_stack || []).map((stack, index) => {
        const paidPrevious = (gameState.chips_paid_previous_streets || [])[index] || 0;
        const paidThis = (gameState.chips_paid_this_street || [])[index] || 0;
        return stack - paidPrevious - paidThis;
    });

    const transformedState = {
        handInfo: {
            players: gameState.num_players || 4,
            stacks: gameState.winner_index !== undefined ? 
                gameState.starting_stack : 
                remainingChips,
            positions: [gameState.dealer_button],
            winner: gameState.winner_index
        },
        gameState: {
            pot: gameState.winner_index !== undefined ? 0 : totalPot,
            prevStreetPot: gameState.winner_index !== undefined ? 0 : prevStreetPot, // Hide prev street pot when showing winner
            current_bets: gameState.winner_index !== undefined ?
                gameState.starting_stack.map((_, i) => i === gameState.winner_index ? gameState.total_pot_won : 0) :
                gameState.chips_paid_this_street || [],
            hands: gameState.hands || [],
            board: (gameState.board || []),
            player_to_act: gameState.player_to_act,
            street: gameState.street || 0,
            round: ['preflop', 'flop', 'turn', 'river'][gameState.street || 0],
            potWon: gameState.winner_index !== undefined,
            player_live: gameState.player_live
        }
    };

    return (
        <div className="game-visualizer">
            <GameTable
                handInfo={transformedState.handInfo}
                gameState={transformedState.gameState}
                rawGameState={gameState}
                payoffs={payoffs}
                cumulativePayoffs={cumulativePayoffs}
            />
        </div>
    );
}

function App() {
    const [gameState, setGameState] = useState(null);
    const [payoffs, setPayoffs] = useState(undefined);
    const [cumulativePayoffs, setCumulativePayoffs] = useState([0, 0, 0, 0]);

    useEffect(() => {
        const socket = io('https://staff-dev1.poker.camp:8001');
        const debugContainer = document.getElementById('debug-container');
        const startButton = document.getElementById('startButton');

        function appendMessage(msg) {
            const msgElement = document.createElement('div');
            try {
                const parsedMsg = JSON.parse(msg);
                console.log(parsedMsg);

                if ('hands' in parsedMsg) {
                    // Check if this is a new street with no actions yet
                    if (parsedMsg.action_history_by_street[parsedMsg.street].length === 0) {
                        const streetNames = ['Preflop', 'Flop', 'Turn', 'River'];
                        const streetCards = parsedMsg.board[parsedMsg.street - 1] || [];
                        
                        if (parsedMsg.street > 0) { // Don't show for preflop
                            msgElement.appendChild(document.createTextNode(`\n`));
                            const b = document.createElement('b');
                            b.style.color = '#444444';
                            b.textContent = `${streetNames[parsedMsg.street]}:`;
                            msgElement.appendChild(b);
                            
                            // Render each card using React
                            const cardContainer = document.createElement('span');
                            cardContainer.style.marginLeft = '0.3em';
                            const root = ReactDOM.createRoot(cardContainer);
                            root.render(
                                <React.Fragment>
                                    {streetCards.map((card, i) => (
                                        <React.Fragment key={i}>
                                            {i == 0 ? '' : ' '}
                                            <TextCard card={card} />
                                        </React.Fragment>
                                    ))}
                                </React.Fragment>
                            );
                            msgElement.appendChild(cardContainer);
                        }
                    }
                } else if ('actor' in parsedMsg) {
                    const verb = parsedMsg.action.verb.toLowerCase();
                    const b = document.createElement('b');
                    b.className = PLAYER_CLASS[parsedMsg.actor];
                    b.textContent = PLAYER_SHORT_NAMES[parsedMsg.actor];
                    msgElement.appendChild(b);
                    msgElement.appendChild(document.createTextNode(` ${verb}s${parsedMsg.action.total ? ` to $${parsedMsg.action.total}` : ''}`));
                } else if ('payoffs' in parsedMsg) {
                    msgElement.appendChild(document.createTextNode('\n'));
                    // Sort players by payoff amount, descending
                    const sortedPayoffs = parsedMsg.payoffs
                        .map((payoff, i) => ({payoff, index: i}))
                        .filter(p => p.payoff !== 0)
                        .sort((a, b) => b.payoff - a.payoff);
                    
                    sortedPayoffs.forEach(({payoff, index}) => {
                        const b = document.createElement('b');
                        b.className = PLAYER_CLASS[index];
                        b.textContent = PLAYER_SHORT_NAMES[index];
                        msgElement.appendChild(b);
                        msgElement.appendChild(document.createTextNode(`: ${payoff > 0 ? '+$' : '-$'}${Math.abs(payoff)}\n`));
                    });
                    msgElement.appendChild(document.createTextNode('\n'));
                }
                // Only update game state if the message contains hands data
                if ('hands' in parsedMsg) {
                    // sample game state data:
                    // {"player_to_act": 1, "action_history": [[2, {"verb": "Raise", "total": 30}], [3, {"verb": "Fold"}], [0, {"verb": "Call"}], [1, {"verb": "Call"}], [0, {"verb": "Check"}]], "action_history_by_street": [[[2, {"verb": "Raise", "total": 30}], [3, {"verb": "Fold"}], [0, {"verb": "Call"}], [1, {"verb": "Call"}]], [[0, {"verb": "Check"}]], [], []], "hands": [[{"rank": "4", "suit": "c"}, {"rank": "A", "suit": "c"}], [{"rank": "A", "suit": "s"}, {"rank": "2", "suit": "d"}], [{"rank": "Q", "suit": "s"}, {"rank": "9", "suit": "s"}], [{"rank": "9", "suit": "h"}, {"rank": "5", "suit": "c"}]], "board": [[{"rank": "7", "suit": "h"}, {"rank": "K", "suit": "h"}, {"rank": "8", "suit": "h"}], [{"rank": "3", "suit": "c"}], [{"rank": "J", "suit": "h"}]], "street": 1, "chips_paid_this_street": [0, 0, 0, 0], "chips_paid_previous_streets": [30, 30, 30, 0], "player_live": [true, true, true, false], "player_action_option": [false, true, true, false], "starting_stack": [1000, 1000, 1000, 1000]}
                    setPayoffs(undefined);
                    setGameState(parsedMsg);
                } else if ('payoffs' in parsedMsg) {
                    // Update game state with payoff information
                    
                    setPayoffs(parsedMsg.payoffs);
                    setCumulativePayoffs(prev => 
                        prev.map((payoff, i) => payoff + (parsedMsg.payoffs[i] || 0))
                    );
                }
            } catch (e) {
                console.log(msg);
                msgElement.style.opacity = "0.3";
                msgElement.textContent = msg;
            }
            debugContainer.appendChild(msgElement);
            debugContainer.scrollTop = debugContainer.scrollHeight;
        }
        
        socket.on('connect', () => {
            appendMessage('Connected to server');
            socket.emit('request_spectate_match', {
                version: "0.1.0",
                params: {
                    game_type: "holdllm",
                    variant: 0
                }
            });
        });

        socket.on('available_spectate_match', (data) => {
            appendMessage('Connected to spectator room');
            setCumulativePayoffs([0, 0, 0, 0]);
        });

        socket.on('game_message', (msg) => {
            appendMessage(msg);
        });

        socket.on('create_match_error', (msg) => {
            appendMessage('Error creating match: ' + msg);
        });

        socket.on('match_ended', () => {
            appendMessage('Match ended');
        });

        return () => socket.disconnect();
    }, []);

    return <GameVisualizer 
        gameState={gameState} 
        payoffs={payoffs}
        cumulativePayoffs={cumulativePayoffs}
    />;
}

ReactDOM.createRoot(document.getElementById('visualization-container')).render(<App />);

        </script>
   </body>
</html>